<!DOCTAPE html>
<html>
<head>
<meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<style>
body{margin:0;padding:0;background:green}
button{
background:#96b52d;
font-size:24px
width:70;height:70;
}
div.bu{
position:absolute;bottom:10%;
}
button.bu{opacity:80%;user-select: none;}


#tool{
position:fixed;top:10;right:10;color:#fff;font-size:32px;background:black;opacity:80%
}
#set{
    display:none;
    max-width:500px;width:90%;
    height:300px;
    position:fixed;top:0;left:0;right:0;bottom:0;
    margin:auto auto;
    background:#ffffff;
    padding:5px;
    border:1px solid #000;border-radius:10px;-moz-border-radius:10px;
    overflow: scroll;
    opacity:50%
}

input[type=checkbox]{
visibility: hidden;
}
input[type=checkbox]::after{
content:" ";
display:block;
width:40px;
height:40px;
background:green;
}
input[type=checkbox]:checked::after{
background:blue;
}

hr {
    height:1px;
    border:none;
    border-top:3px dashed #df0000;
}
.dt {
    background:#cfa;/*(#000)。#efff6d黄)*/
    box-sizing:boder-box;
    left:0;
    right:0;
    top:0;
    position:absolute;
    padding:0px;
    color:#f90;/*f00*/
    height:80px;
}
.dbo1 {
    max-width:925px;width:90%;
    border:1px solid #f90;
    border-radius:10px;-moz-border-radius:10px;
    padding:10px;
    color:#f90;
    background:#aff;
    margin:0 auto;
    /*flex-wrap:wrap;
    display:flex;*/
}
/*tool为悬浮的工具栏*/
.tool{
    /*display:none;*/
    position:fixed;
    top:15;right:15;
    background:;opacity:50%;
    /*width:55px;height:50px;*/
    transition:1s;
}
.showtool{
    opacity:90%;
}
.showtool .sp1{
    transition:1s;
}
.tool1{
    border:2px solid #ff0000;
    background:#FFFFFF;
    text-align:center;
    width:50px;height:50px;
    box-sizing:border-box;
    line-height:50px;
}
.tool2{
    display:none;
    transition:1s;
    opacity:10%;
}
.ticon{/*工具栏图标*/
    font-size:45px;
    font-weight:bold;
    color:#333333;
}
.tool:hover .tool1{
    display:block;
    opacity:90%;
}
.tool:hover .sp1{
    transform: rotate(180deg);
    -ms-transform: rotate(180deg); /* IE 9 */
    -webkit-transform: rotate(180deg); /* Safari and Chrome */
}
/*set是设置弹窗*/
#set{
    display:none;
    max-width:500px;width:90%;
    height:300px;
    position:fixed;top:0;left:0;right:0;bottom:0;
    margin:auto auto;
    background:#ffffff;
    padding:5px;
    border-radius:10px;-moz-border-radius:10px;
    overflow: scroll;
}
#set .hs{
    float:right;
}
div.sesw{
    border-bottom:1px solid #ccc;
    height:40px;
}
/*.switch开关*/
.switch {
  position: relative;
  display: inline-block;
  width: 56px;
  height: 30px;
  float:right;
}
.switch input {
    display:none;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}
.slider:before {
  position: absolute;
  content: "";
  height: 22px;
  width: 22px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}
input:checked + .slider {
  /*background-color: #ff0000;*/
  background-color: #2196F3;
}
input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}
input:checked + .slider:before {
  -webkit-transform: translateX(26px);
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}
.slider.round {
  border-radius: 34px;
}
.slider.round:before {
  border-radius: 50%;
}
/*字体*/
/*@font-face {
    font-family: pigfont;
    src: url()
}*/
</style>
<!--link rel="stylesheet" href="style.css"-->
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
</head>
<body>
<!--html-->
<noscript>noscript</noscript>
<div id="tool" onclick="tool('block')"><i class="fa fa-gear"></i></div>
<div id="set"></div>
<div class="bu">

<button id="fullscreen" onclick="document.documentElement.webkitRequestFullScreen();">全屏</button>
<div>
<input type="range" min="0" max="10" step="1" oninput="view.lookat(0,0,(this.value-5)*0.1);this.value=5;">
</div>
<input type="range" min="0" max="10" step="1" oninput="view.lookat((this.value-5)*10,0,0);this.value=5;">
<input type="range" min="0" max="10" step="1" oninput="view.lookat(0,(this.value-5)*10,0);this.value=5;">
<input type="text" onchange="eval(this.value)">
<input type="checkbox" id="check">
</div>

<canvas id="canvas" width="1200" height="675" style="width:100vw;">你的浏览器不支持canvas</canvas>
<!--script src="matter.min.js"></script-->
<script src="https://cdn.bootcdn.net/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<!--script src="matter-spring.js"></script-->
<script src="tool.js"></script>
<script>
function dgbyid(idid){
return document.getElementById(idid)
}
if(true){dgbyid("set").innerHTML='<div style="text-align:center;">设置<div class="hs"><a onclick="tool(\'none\')"><i class="fa fa-times"></i></a></div></div><hr style="height:1px;border:none;border-top:1px solid #ccc;"/><div class="sesw">开关示例<label class="switch"><input id="seta" type="checkbox" onchange="timesp()"><div class="slider round"></div></label><div id="log"></div></div>';tool("block")}
function tool(display){
dgbyid("set").style.display=display;
}
tool("none")

function at(n) {
    // ToInteger() abstract op
    n = Math.trunc(n) || 0;
    // Allow negative indexing from the end
    if (n < 0) n += this.length;
    // OOB access is guaranteed to return undefined
    if (n < 0 || n >= this.length) return undefined;
    // Otherwise, this is just normal property access
    return this[n];
}
for (const C of [Array, String, Reflect.getPrototypeOf(Int8Array)]) {
    Object.defineProperty(C.prototype, "at",
        {
            value: function(n){
                // ToInteger() abstract op
                n = Math.trunc(n) || 0;
                // Allow negative indexing from the end
                if (n < 0) n += this.length;
                // OOB access is guaranteed to return undefined
                if (n < 0 || n >= this.length) return undefined;
                // Otherwise, this is just normal property access
                return this[n];
            },
            writable: true,
            enumerable: false,
            configurable: true
        });
}
var _clear=(function(){
//兼容
    var _getTexture = function(render, imagePath) {
        var image = render.textures[imagePath];

        if (image)
            return image;

        image = render.textures[imagePath] = new Image();
        image.src = imagePath;

        return image;
    };
    Matter.Render.bodies = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            showInternalEdges = options.showInternalEdges || !options.wireframes,
            body,
            part,
            i,
            k;

        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                if (!part.render.visible)
                    continue;

                if (options.showSleeping && body.isSleeping) {
                    c.globalAlpha = 0.5 * part.render.opacity;
                } else if (part.render.opacity !== 1) {
                    c.globalAlpha = part.render.opacity;
                }

                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {
                    // part sprite
                    var sprite = part.render.sprite,
                        texture = _getTexture(render, sprite.texture);

                    c.translate(part.position.x, part.position.y);
                    c.rotate(part.angle);

                    if(sprite.cutx!=null&&sprite.cutx!=undefined){
                        c.drawImage(
                            texture,
                            sprite.cutx,
                            sprite.cuty,
                            sprite.cutwidth,
                            sprite.cutheight,
                            texture.width * -sprite.xOffset * sprite.xScale,
                            texture.height * -sprite.yOffset * sprite.yScale,
                            texture.width * sprite.xScale,
                            texture.height * sprite.yScale
                        );
                    }else{
                        c.drawImage(
                            texture,
                            texture.width * -sprite.xOffset * sprite.xScale,
                            texture.height * -sprite.yOffset * sprite.yScale,
                            texture.width * sprite.xScale,
                            texture.height * sprite.yScale
                        );
                    }

                    // revert translation, hopefully faster than save / restore
                    c.rotate(-part.angle);
                    c.translate(-part.position.x, -part.position.y);
                } else {
                    // part polygon
                    if (part.circleRadius) {
                        c.beginPath();
                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);
                    } else {
                        c.beginPath();
                        c.moveTo(part.vertices[0].x, part.vertices[0].y);

                        for (var j = 1; j < part.vertices.length; j++) {
                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                                c.lineTo(part.vertices[j].x, part.vertices[j].y);
                            } else {
                                c.moveTo(part.vertices[j].x, part.vertices[j].y);
                            }

                            if (part.vertices[j].isInternal && !showInternalEdges) {
                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                            }
                        }

                        c.lineTo(part.vertices[0].x, part.vertices[0].y);
                        c.closePath();
                    }

                    if (!options.wireframes) {
                        c.fillStyle = part.render.fillStyle;

                        if (part.render.lineWidth) {
                            c.lineWidth = part.render.lineWidth;
                            c.strokeStyle = part.render.strokeStyle;
                            c.stroke();
                        }

                        c.fill();
                    } else {
                        c.lineWidth = 1;
                        c.strokeStyle = '#bbb';
                        c.stroke();
                    }
                }

                c.globalAlpha = 1;
            }
        }
    };
    return null;
})();
//matter0.19
// module模块 aliases
var Engine = Matter.Engine,
    Render = Matter.Render,
    Runner = Matter.Runner,
    Bodies = Matter.Bodies,
    Common = Matter.Common,
    Constraint = Matter.Constraint,//约束
    Composite = Matter.Composite,
    Composites = Matter.Composites,
    Body = Matter.Body,
    MouseConstraint = Matter.MouseConstraint,
    Mouse = Matter.Mouse,
    Query = Matter.Query,
    Events = Matter.Events,
    Example = Matter.Example,
    Vector = Matter.Vector;
    
//Matter.use('matter-springs');//弹簧插件

// create an engine
var engine = Engine.create({
  gravity:{x:0,y:1.2},
  timing:{timeScale:1}
});

// create a renderer
var render = Render.create({
    canvas: dgbyid("canvas"),
    //element: document.body,
    engine: engine,
    options: {
        width: 1200,
        height: 675,
        background:"url(https://s1.imagehub.cc/images/2023/05/14/Night_Sky_Texture.png)",
        hasBounds:true,
        //showAngleIndicator: true,
        showPerformance: true,
        showDebug:true,
        showIds: true,
        showCollisions: true,
        //showSeparations: true,
        //showVelocity: true,
         wireframes: false//线框模式
    }
});

//创造界面


</script>

<script src="filebag.js"></script>
<!--/*  资源链接  */-->

<script>
//预加载
if(false){
render.options.wireframes=true;
for(let imagePath of filebag.ihpnglink){
    imagePath="https://www.imagehub.cc/"+imagePath;
    let image = render.textures[imagePath];

    if (!image){
        image = render.textures[imagePath] = new Image();
        image.src = imagePath;
    }
}

let isload=function(){
    let t=0
    for(let v of Object.values(render.textures)){
        if(v.complete){
            t++
        }
    }
    if(t===Object.values(render.textures).length){
        render.options.wireframes=false;
    }
    //alert(`${t}/${Object.values(render.textures).length}`);
}
setInterval(isload,3000)
}
</script>

<script src="options.js"></script>
<!--/*  贴图等  */-->

<script>
//仅贴图的物体
var urbody=(function(){
    let obj={};
    var _getTexture = function(render, imagePath) {
        var image = render.textures[imagePath];

        if (image)
            return image;

        image = render.textures[imagePath] = new Image();
        image.src = imagePath;

        return image;
    };
    var _setValue = function(value, defaultvalue) {
        if(typeof value==="undefined"){
            value=defaultvalue;
        }
        return value;
    };
    obj.create=function(position,options){
        return {
            position:Vector.clone(position),
            texture: options.texture,
            angle: _setValue(options.angle,0),
            cutx: options.cutx,
            cuty: options.cuty,
            cutwidth: options.cutwidth,
            cutheight: options.cutheight,
            xOffset: _setValue(options.xOffset,0.5),
            yOffset: _setValue(options.yOffset,0.5),
            xScale: _setValue(options.xScale,1),
            yScale: _setValue(options.yScale,1),
            birth: engine.timing.timestamp,
            parent: undefined,
            relative: false,
            type:"urbody"
        };
    };
    //obj.setPosition=();
    obj.worldprototype={
        add(part){
            if(Common.isArray(part)){
                for(let p of part){
                    this.all.push(p);
                }
            }else{
                this.all.push(part)
            }
        },
        remove(){
            if(Common.isArray(part)){
                for(let p of part){
                    this.all.push(p);
                }
            }else{
                this.all.push(part)
            }
        },
        render:function(){
            let world=this;
            Render.startViewTransform(render);
            let c=render.context;
            for(let b of world.all){
                let po;
                if(b.parent&&b.relative){
                    po=Vector.add(b.position,b.parent.position);
                    po.angle=b.angle+b.parent.angle;
                }else{
                    po=b.position;
                    po.angle=b.angle;
                }
                c.translate(po.x, po.y);
                c.rotate(po.angle);
                let texture=_getTexture(render,b.texture);
                let sprite=b;
                c.drawImage(
                    texture,
                    sprite.cutx,
                    sprite.cuty,
                    sprite.cutwidth,
                    sprite.cutheight,
                    texture.width * -sprite.xOffset * sprite.xScale,
                    texture.height * -sprite.yOffset * sprite.yScale,
                    texture.width * sprite.xScale,
                    texture.height * sprite.yScale
                );
                c.translate(-po.x, -po.y);
                c.rotate(-po.angle);
            }
            Render.endViewTransform(render);
        },
        run(){
            Events.on(render,"afterRender",this.render);
            this.enabled=true;
        },
        stop(){
            Events.off(render,"afterRender",this.render);
            this.enabled=false;
        }
    };
    obj.createworld=function(){
        let world={
            all:[],
            enabled:false,
            type:"urworld"
        };
        for(let i in obj.prototype){
            world[i]=obj.worldprototype[i];
        }
        return world;
    };
    obj.rotateAbout=function(body,angle,point){
        Vector.rotateAbout(body.position,angle,point,body.position);
        if(!body.relative){
            body.angle+=angle;
        }
    };
    obj.render=function(world){
        Render.startViewTransform(render);
        let c=render.context;
        for(let b of world.all){
            let po;
            if(b.parent&&b.relative){
                po=Vector.add(b.position,b.parent.position);
                po.angle=b.angle+b.parent.angle;
            }else{
                po=b.position;
                po.angle=b.angle;
            }
            c.translate(po.x, po.y);
            c.rotate(po.angle);
            let texture=_getTexture(render,b.texture);
            let sprite=b;
            c.drawImage(
                texture,
                sprite.cutx,
                sprite.cuty,
                sprite.cutwidth,
                sprite.cutheight,
                texture.width * -sprite.xOffset * sprite.xScale,
                texture.height * -sprite.yOffset * sprite.yScale,
                texture.width * sprite.xScale,
                texture.height * sprite.yScale
            );
            c.translate(-po.x, -po.y);
            c.rotate(-po.angle);
        }
        Render.endViewTransform(render);
    };
    return obj;
})();
var urworld=urbody.createworld();
urworld.all.push(urbody.create({x:0,y:0},{
  texture: "https://s1.imagehub.cc/images/2023/05/03/IngameAtlas.png",
  cutx: 679,
  cuty: 519,
  cutwidth: 110,
  cutheight: 110,
  xScale: 100/2024,
  yScale: 100/2024
}));


</script>

<script>
var controlConstraint={
  create: function(bodya,bodyb,move,stiffness,angularStiffness,length,movem){
      let xx = 0,
          yy = 0,
          xb=0,
          yb=0;
      movem=movem || 20
      return Constraint.create({
          pointA: { x: xx, y: yy },
          pointB: { x: xb, y: yb },
          bodyA: bodya,
          bodyB: bodyb,
          // stiffness: stiffness,
          damping: 0,
          length: length,
          type: 'constraint'
      });
  },
  create2: function(bodya,bodyb,pointa,stiffness,angularStiffness,length){
    return Constraint.create({
        pointA: pointa,
        pointB: {
            x: pointa.y===30||-30 ? -pointa.x : -pointa.y,
            y: pointa.x===30||-30 ? -pointa.y : -pointa.x
        },
        bodyA: bodya,
        bodyB: bodyb,
        stiffness: stiffness,
        angularStiffness: angularStiffness,
        length: length,
        type: 'constraint'
    });
  },
  connect: function(bodya,bodyb,pointa,stiffness){
    if(pointa.x!==0){xx=pointa.x;xb=xx;yy=20;yb=-20;}
    else{xx=20;xb=-20;yy=pointa.y;yb=yy;}
    return [this.create2(bodya,bodyb,{x:xx,y:yy},stiffness,0.7),
    this.create2(bodya,bodyb,pointa,stiffness,0.7),
    this.create2(bodya,bodyb,{x:xb,y:yb},stiffness,0.7)]
  },
  connect2: function(bodya,bodyb,xory,stiffness){
    function gbp(body){//get build position
      return Vector.mult(vector_round(Vector.div(body.position,100)),100)
    }
    function vector_round(vector){
      return {x: Math.round(vector.x), y: Math.round(vector.y)};
    }
    let mo= xory===0 ? {x:-50,y:0} : {x:0,y:-50};
    return Constraint.create({
        pointA: Vector.add(Vector.mult(Vector.sub(gbp(bodya),bodya.position),1),mo),
        pointB: Vector.sub(Vector.mult(Vector.sub(gbp(bodyb),bodyb.position),1),mo),
        bodyA: bodya,
        bodyB: bodyb,
        stiffness: stiffness,
        type: 'constraint'
    });
  },
  removebybody(event){
    let body=event.object;
    if(body.type==="body"){
        for(let c of Composite.allConstraints(engine.world)){
            if(c.bodyA.id===body.id||c.bodyB.id===body.id){
                Composite.remove(engine.world,c);
            }
        }
    }
  }
};
Events.on(engine.world, "beforeRemove", controlConstraint.removebybody);

var lattice=100;
var build = {
  sameposition:function(oa,ob){
    return oa.x===ob.x&&oa.y===ob.y;
  },
  display:{
    renderurworld:function(){
        urbody.render(urworld);
    },
    show:function(){
        Events.on(render,"afterRender",this.renderurworld)
    },
    hide:function(){
        Events.off(render,"afterRender",this.renderurworld)
    }
  },
  gird:{
    all: (function(){
        let girds=[],
            position={x:0,y:0},
            sprite={
                texture: "https://s1.imagehub.cc/images/2023/05/03/MenuAtlas2.png",
                cutx: 1774,
                cuty: 1412,
                cutwidth: 195,
                cutheight: 195,
                xScale: 0.050,
                yScale: 0.050
            };
        for(let c=0;c<3;c++){
            for(let r=0;r<4;r++){
                let b=urbody.create(Vector.add(position,{x:100*r,y:100*c}),sprite)
                girds.push(b);
                urworld.all.push(b);
            }
        }
        this.position=girds[0].position
        return girds;
    })(),
    position: undefined,
    translate(position){
        for(let i of this.all){
            i.position=Vector.add(position,i.position);
        }
    },
    setposition(position){
        position=build.round(
            Vector.sub(
                position,
                Vector.div(
                    Vector.add(
                        this.all[0].position,
                        this.all.at(-1).position
                    ),
                    2
                )
            )
        );
        this.translate(position);
    },
  },
  part:{
    all:[],
    get(position){
        position=build.round(position);
        ingird=[];
        for(let part of this.all){
            if(build.sameposition(part.position,position)){
                ingird.push(part);
            }
        }
        return ingird;
    },
    add(position,type){
        position=build.round(position);
        let ingird=this.get(position);
        if(ingird.length>1){
            return false;
        }else if(ingird.length===1&&partsource.isbox(ingird[0].label)===partsource.isbox(type)){
            return false;
        }
        
        let sprites=partsource.getsprites(type)
        let part={
            position:position,
            angle:0,
            id:0,
            label: type,
            sprites: sprites,
            type:"part"
        };
        for(let sprite of sprites){
            sprite.parent=part;
            sprite.relative=true;
            urworld.all.push(sprite);
        }
        this.all.push(part)
        return true;
    },
    translateparts(position){
        for(let part of this.all){
            part.position.x+=position.x;
            part.position.y+=position.y;
        }
    },
    rotate(part){
        let angle=Math.PI/2;
        for(let s of part.sprites){
            urbody.rotateAbout(s,angle,{x:0,y:0});
        }
        part.angle+=angle;
    },
    remove(part){
        for(let sprite of part.sprites){
            removefromarr(urworld.all,sprite);
        }
        removefromarr(this.all,part);
        function removefromarr(arr,value){
            arr.splice(Common.indexOf(arr,value),1);
        }
    },
    clear(){
        while(this.all.length!==0){
            this.remove(this.all[0]);
        }
    },
    save(){
        alert(JSON.stringify(this.all))
    },
    load(){
        //JSON.parse
    }
  },
  round:function(position){
    return {
      x:Math.round((position.x)/100)*100,
      y:Math.round((position.y)/100)*100
    };
  }
};
var partsource={
    isbox(type){
        return type.includes("box");
    },
    getsprites(type){
        let sprites=[];
        switch(type){
            case "mubox0":
            sprites.push(urbody.create({x:0,y:0},toptions.mubox0.render.sprite));
            break;
            case "febox0":
            sprites.push(urbody.create({x:0,y:0},toptions.febox0.render.sprite));
            break;
            
        }
        return sprites;
    },
    
};
build.display.show()
var buildgird = {
  size: 100,
  positiontogird:function(position){
    return {x: position.x/100, y: position.y/100};
  },
  girdtoposition:function(position){
    return {x: position.x*100, y: position.y*100};
  },
  issameposition:function(oa,ob){
    return oa.x===ob.x&&oa.y===ob.y;
  },
  gird: Composites.stack(-100-50, -100-50, 4, 3, 0, 0, function(x, y) {
    return Bodies.rectangle(x, y, 100, 100, {
      render: {
        //fillStyle: 'rgba(0,0,0,0.5)',
        //strokeStyle: 'black'
        sprite: {
            texture: "https://s1.imagehub.cc/images/2023/05/03/MenuAtlas2.png",
            cutx: 1774,
            cuty: 1412,
            cutwidth: 195,
            cutheight: 195,
            xScale: 0.050,
            yScale: 0.050
        }
      },
      isStatic:true,
      isSensor:true,
      label: {
        name: "gird",
        insidebox: undefined,
        insidebody: undefined
      }
    });
  }),
  move: function(position,absolute){
    if(absolute){
      position=buildgird.round(Vector.sub(position,Vector.div(Vector.add(Composite.allBodies(buildgird.gird)[0].position,Composite.allBodies(buildgird.gird).at(-1).position),2)));
    }
    Composite.translate(buildgird.gird, position, true)
  },
  show: function(){
    Composite.add(engine.world, [buildgird.gird])
  },
  hide: function(){
    Composite.remove(engine.world, [buildgird.gird])
  },
  bodies: Composite.create({label: "buildgird"}),
  add:function(body){
    Composite.add(buildgird.gird,body)
  },
  isput:function(position){
    return Composite.allBodies(buildgird.bodies).some((body)=>{return buildgird.issameposition(body.position,position)})
  },
  start:function(){
    for(let i of Composite.allBodies(buildgird.bodies)){
      Body.setStatic(i,false);
    }
    Composite.move(buildgird.bodies,Composite.allBodies(buildgird.bodies),engine.world)
  },
  generate:{
    bodies(){
        for(let part of build.part.all){
            
        }
    }
  },
  round:function(position){
    return {
      x:Math.round((position.x)/100)*100,
      y:Math.round((position.y)/100)*100
    };
  }
};
//buildgird.show()
//Composite.rotate(buildgird.gird,Math.PI / 180 * 30,{x:0,y:0})

/*
{
    position:{},
    
    type:"buildbody"
}
*/
function arrequa(arr1,arr2){
  if(arr1.length===arr2.length){
    for(let i=0;i<arr1.length;i++){
      if(arr1[i]!==arr2[i]){return false}
    }
    return true;
  }else{
    return false;
  }
}
var bodymodel={
  mubox:Bodies.rectangle(0*lattice, 0*lattice, 1*lattice, 1*lattice, toptions.mubox),
  febox:Bodies.rectangle(0*lattice, 0*lattice, 1*lattice, 1*lattice, toptions.febox),
  //muwheel:wwheel(0*lattice, 0*lattice, 8.5, 58, 34, toption.muwheel0.wsjx.render, toption.muwheel0.wcircle.render),
  dpen:Bodies.polygon((0+0.25)*lattice, 0*lattice, 3, 50, toptions.dpen0),
  TNT:Bodies.rectangle(0*lattice, 0*lattice, 1*lattice, 1*lattice, toptions.tnt0),
  g:function(position,type){
    ///create
    let body=undefined;
    let box=0;
    switch(type){
      case "mubox":
      body=Bodies.rectangle(position.x, position.y, 1*lattice, 1*lattice, toptions.mubox0);
      box=1;
      break;
      case "febox":
      body=Bodies.rectangle(position.x, position.y, 1*lattice, 1*lattice, toptions.febox0);
      box=1;
      break;
      case "pig":
      body=Bodies.circle(position.x, position.y, 44, toptions.pig0);
      body.label={};
    Object.assign(body.label,{
      name: "pig"
    });
    logs(body.label.name+"$$")
      break;
      case "egg":
      body=Bodies.circle(position.x, position.y, 44, toptions.egg0);
      case "dpen":
      body=Bodies.polygon(position.x+25, position.y, 3, 50, toptions.dp0);
      body.label={};
      Object.assign(body.label,{buildposition: position})
      break;
      case "TNT":
      body=Bodies.rectangle(position.x, position.y, 1*lattice, 1*lattice, toptions.tnt0);
      body.label={};
      Object.assign(body.label,{name: "TNT",erange:200,eforce:1});
      break;
      case "rocket":
      break;
      case "muwheel":
      body=wwheel(position.x, position.y, 8.5, 58, 34, toptions.muwheel0.wsjx.render, toptions.muwheel0.wcircle.render);
    }
    if(box===0){
      thingsp.thingss.push(body);
    }else{
      boxsp.boxss.push(body);
    }
    return body;
  }
};
var thingsp={
  thingss:[],
  thingssxy:[],
  thingssxyx:[],
  thingssxyy:[]
}
var boxsp={
  boxss:[],
  boxssxy:[],
  boxssxyx:[],
  boxssxyy:[]
}


function thingsadd(things){things.create();}
  try{
var dpen=bodymodel.g({x:0,y:0},"dpen")
  //new Box({x:1,y:0},toptions.febox0).create()
  //new Box({x:2,y:0},toptions.febox0).create()
  bodymodel.g({x:400,y:0},"TNT")
  //var b1=new Box({x:3,y:0},toptions.febox0);
  var b2=bodymodel.g({x:300,y:0},"febox")
  
  bodymodel.g({x:500,y:-100},"febox")
  bodymodel.g({x:500,y:0},"febox")
  bodymodel.g({x:500,y:0},"TNT")
  //new Box({x:3,y:-1},toptions.febox0).create()
//b1.start()
//Matter.Events.on(b2, "click", function(e){logs(e)})
bodymodel.g({x:100,y:100},"muwheel");
var wheel=bodymodel.g({x:300,y:100},"muwheel");
var pig0=bodymodel.g({x:200,y:0},"pig")
bodymodel.g({x:500,y:100},"muwheel")
bodymodel.g({x:100,y:0},"febox")
bodymodel.g({x:200,y:0},"febox")
//bodymodel.g({x:300,y:0},"febox")


  }catch(e){logs(e)}

var bodyss=thingsp.thingss.concat(boxsp.boxss);



//数组内双向对比，赋值重复出现的值。

//连接框与其内物
function generate(){
  //生成建造内容
  function compareAr(arr1, arr2, isposition) {
    if(isposition){
      return arr1.filter((v) => {
        return arr2.map((w)=>{return w.x+","+w.y}).indexOf((v.x+","+v.y)) !== -1;
      });
    }else{
      return arr1.filter((v) => {
        return arr2.indexOf(v) !== -1;
      });
    }
  }
  //compareAr()取交集
  for ( let i of compareAr(boxsp.boxss.map((v)=>{return v.position}), thingsp.thingss.map((v)=>{return v.position}), true) ){
      let group=Body.nextGroup(true);
      let b1=bodyinposition(i,boxsp.boxss);
      let b2=bodyinposition(i,thingsp.thingss);
      b1.collisionFilter.group=group;
      b2.collisionFilter.group=group;
      bodyss.push(controlConstraint.create(b1,b2,0,1,1));
  } //连接框物
  
  
  
  for ( let i of compareAr(boxsp.boxss.map((v)=>{return v.position}),boxsp.boxss.map((v)=>{return {x:v.position.x+100,y:v.position.y}}),true) ){
      bodyss=bodyss.concat(controlConstraint.connect2(bodyinposition(i,boxsp.boxss),bodyinposition({x:i.x-100,y:i.y},boxsp.boxss),0,1));
  }
  for ( let i of compareAr(boxsp.boxss.map((v)=>{return v.position}),boxsp.boxss.map((v)=>{return {x:v.position.x,y:v.position.y+100}}),true) ){
      bodyss=bodyss.concat(controlConstraint.connect2(bodyinposition(i,boxsp.boxss),bodyinposition({x:i.x,y:i.y-100},boxsp.boxss),1,1));
  }
  function bodyinposition(position,arr){
    for(let i of arr){
      if(build.sameposition(position, i.label.buildposition||i.position)){
        if(i.type!=="composite"){
          return i
        }else{
          return i.label.connectpart
        }
      }
    }
  }
  
  
  try{
  bodyss=bodyss.concat(controlConstraint.connect2(Composite.allBodies(wheel)[0],b2,1,1));
  bodyss=bodyss.concat(controlConstraint.connect2(bodyinposition({x:100,y:100},thingsp.thingss),bodyinposition({x:100,y:0},boxsp.boxss),1,1));
  bodyss=bodyss.concat(controlConstraint.connect2(bodyinposition({x:100,y:0},boxsp.boxss),bodyinposition({x:0,y:0},thingsp.thingss),0,1));
  }catch(e){logs(e)}
}
generate()
logs(Composite.allBodies(wheel)[0].position.x+","+Composite.allBodies(wheel)[0].position.y)
//bodyss=bodyss.concat(connectAB());
//function duplicates(arr) {
//    return arr.filter((e,i) => arr.indexOf(e)!==arr.lastIndexOf(e) && arr.indexOf(e)===i);
//}
for(let i of Composite.allBodies(engine.world)){
logs(i.id)
}

function wwheel(xx, yy, width, height, wheelSize, objectB, objectW) {
    yy=yy-30;

    var group = Body.nextGroup(true),
        wheelBase = 60,
        wheelOffset = -height * 0.5 + wheelBase,
        wheelXOffset = 0;
    
    objectB=objectB || {};
    objectW=objectW || {};
    let mwheel0 = Composite.create({ label: {name:'mwheel0'} ,position: {x:xx,y:yy+30}}),//position为自定义
        body = Bodies.trapezoid(xx, yy, width, height, -10, {
            render:objectB,
            collisionFilter: {
                group: group
            }
            
            //,chamfer: {radius: height * 0.5},density: 0.0002
        });

    let wheelA = Bodies.circle(xx + wheelXOffset, yy + wheelOffset, wheelSize, { 
        render:objectW,
        collisionFilter: {
            group: group
        },
        friction: 0.5
    });

    let axelA = Constraint.create({
        bodyA: wheelA,
        bodyB: body,
        pointB: { x: wheelXOffset, y: wheelOffset },
        stiffness: 1,
        length: 0
    });
                    
    
    Composite.addBody(mwheel0, body);
    mwheel0.label.connectpart = body;
    Composite.addBody(mwheel0, wheelA);
    Composite.addConstraint(mwheel0, axelA);

    return mwheel0;
};//生成轮子



/*try{
var mouse = Mouse.create(render),
mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
        stiffness: 0.2,
        render: {
            visible: false
        }
    }
});
Composite.add(engine.world, mouseConstraint);
render.mouse = mouse;
}catch(e){logs(e)}*/

//var ww=wwheel(0,3*lattice,9,58,34,toptions.muwheel0.wsjx.render,toptions.muwheel0.wcircle.render);
//Composite.rotate( ww, Math.PI/4, {x:50,y:50}, false);
//Composite.add(engine.world, ww)



// createing 创建物品
var ground = [
  Bodies.rectangle(400, 1110, 9910, 60, { isStatic: true })
  //Bodies.rectangle(400, 610, 910, 70, { isStatic: true })
];
//地面
//var dpen=Matter.Bodies.polygon(1.25*lattice, 2*lattice, 3, 50, toptions.dp0)


var softBody = Composites.softBody(100, 400, 20, 4, 0, 5, true, 15, {
    friction: 0.05,
    frictionStatic: 0.1,
    render: { visible: true } 
}, {
render: { visible: true }
});//软体



    /**添加鼠标控制*/
    /*var mouseConstraint = Matter.MouseConstraint.create(engine, {
        element: document.body
    });*/



//var bcst = [];
//bcst=bcst.concat(controlConstraint.connect(mubox0,dpen,{x:-30,y:0},0.4))
//var wsjx2=Composite.allBodies(mwheel2)[0]
//bcst=bcst.concat(controlConstraint.connect(febox0,wsjx2,{x:0,y:20},0.4))

//添加所有物品到world里
//Composite.add(engine.world, [mubox0, febox0, pig0,egg0, dpen]);//stack,mwheel,softBody
Composite.add(engine.world, ground)
//Composite.add(engine.world, bcst)
Composite.add(engine.world, bodyss)

/*
    if (typeof fetch !== 'undefined') {
        let select = function(root, selector) {
            return Array.prototype.slice.call(root.querySelectorAll(selector));
        };

        let loadSvg = function(url) {
            return fetch(url)
                .then(function(response) { return response.text(); })
                .then(function(raw) { return (new window.DOMParser()).parseFromString(raw, 'image/svg+xml'); });
        };

        loadSvg('./svg/terrain.svg')
            .then(function(root) {
                var paths = select(root, 'path');

                var vertexSets = paths.map(function(path) { return Svg.pathToVertices(path, 30); });

                var terrain = Bodies.fromVertices(400, 350, vertexSets, {
                    isStatic: true,
                    render: {
                        fillStyle: '#060a19',
                        strokeStyle: '#060a19',
                        lineWidth: 1
                    }
                }, true);

                Composite.add(world, terrain);

                var bodyOptions = {
                    frictionAir: 0, 
                    friction: 0.0001,
                    restitution: 0.6
                };
                
                Composite.add(world, Composites.stack(80, 100, 20, 20, 10, 10, function(x, y) {
                    if (Query.point([terrain], { x: x, y: y }).length === 0) {
                        return Bodies.polygon(x, y, 5, 12, bodyOptions);
                    }
                }));
            });
    } else {
        Common.warn('Fetch is not available. Could not load SVG.');
    }
*/


//运行渲染器
Render.run(render);
//创建runner
var runner = Runner.create();
//运行引擎
Runner.run(runner, engine);

//Engine.run(engine);
//Render.run(render);




var view=(function(){
    //视野
    let view={};
    //初始化
    view.position=Vector.create();
    view.size=1;
    view.body=undefined;
    view.relativeposition=Vector.create();
    view.isfollow=false;
    let minsize=0.5;
    let maxsize=50;
    
    view.csize=function(size){
        if(size<minsize){
            this.size=minsize;
        }else if(size>maxsize){
            this.size=maxsize;
        }else{
            this.size=size;
        }
    };
    view.cposition=function(position){
        this.position.x=position.x;
        this.position.y=position.y;
    };
    view.update=function(){
        let offsetleft=render.options.width/2*this.size;
        let offsettop=render.options.height/2*this.size
        Render.lookAt(render, {
          min: { x: this.position.x-offsetleft, y: this.position.y-offsettop },
          max: { x: this.position.x+offsetleft, y: this.position.y+offsettop }
        });
    };
    
    view.lookat=function(x,y,csize,mult){
        if(csize!==0){
            if(mult){
              view.csize(view.size*csize);
            }else{
              view.csize(view.size+csize);
            }
        }
        
        let size=view.size;
        if(view.isfollow){
          view.relativeposition.x+=x*size;
          view.relativeposition.y+=y*size
        }else{
          view.position.x+=x*size;
          view.position.y+=y*size;
        }
        
        view.update();
        
        build.gird.setposition(view.position)
    };
    
    view.follow=function(){
        if(view.isfollow){
            Vector.add(view.body.position,view.relativeposition,view.position);
            view.update();
        }
    };
    
    Events.on(runner, "beforeUpdate", view.follow);
    
    //跟随
    render.canvas.addEventListener("dblclick",function(event){
        view.isfollow=!view.isfollow;
    },true);
    
    //记忆
    let remember={
        load(){
            if(localStorage.view){
                let thedata=JSON.parse(localStorage.view);
                view.position.x=(thedata.position.x);
                view.position.y=(thedata.position.y);
                view.size=(thedata.size);
                view.update();
            }
        },
        save(){
            localStorage.view=JSON.stringify({
                position: view.position,
                size: view.size
            });
        }
    }
    remember.load();
    
    //输入相关
    let input={
      offset: Vector.create(), // 拖动偏移
      curOffset: Vector.create(), // 记录上一次的偏移量
      position: Vector.create(), // 记录鼠标点击Canvas时的坐标
      touchOffset2: Vector.create(), // 记录第二指触摸点击Canvas时的坐标
      mousePosition: Vector.create(), 
      scaleStep: 0.2,
      scale: 1,
      preScale: 1,
      isMove: 0,
      onMousedown(e) {
        if (e.button === 0) {
          // 鼠标左键
          input.position.x = e.x;
          input.position.y = e.y;
          window.addEventListener('mousemove', input.onMousemove);
          window.addEventListener('mouseup', input.onMouseup);
          //logs(input.position.x)
        }
      },
      onMousemove(e) {
       Vector.add(input.curOffset,Vector.sub(e,input.position),input.offset)
    
       let changex=render.canvas.offsetWidth/render.options.width;
       let changey=render.canvas.offsetHeight/render.options.height;
       view.lookat(-(e.x - input.position.x)/changex, -(e.y - input.position.y)/changey, 0);
       input.position.x=e.x;
       input.position.y=e.y;
      },
      onMouseup() {
        input.curOffset.x = input.offset.x;
        input.curOffset.y = input.offset.y;
        //logs(input.curOffset.x)
        window.removeEventListener('mousemove', input.onMousemove);
        window.removeEventListener('mouseup', input.onMouseup);
        remember.save();
      },
      onWheel(e){
        //chrome1
        // 记录当前鼠标点击的坐标
        input.mousePosition.x = e.offsetX; 
        input.mousePosition.y = e.offsetY; 
        
        // 计算缩放比例
        let scaleFactor = 1+0.2*(Math.sign(event.deltaY) > 0 ? -1 : 1);
        //计算偏移
        let offset = {
            x: -(input.mousePosition.x - render.options.width / 2) * (1 - scaleFactor),
            y: -(input.mousePosition.y - render.options.height / 2) * (1 - scaleFactor)
        };
        
        
        Vector.sub(view.position,Vector.mult(offset,view.size),view.position);
        view.lookat(0,0,scaleFactor,true);
      },
      onTouchstart(e) {
        //e.preventDefault();
        input.position.x = e.targetTouches[0].pageX;
        input.position.y = e.targetTouches[0].pageY;
        if(e.targetTouches[1]){
          input.touchOffset2.x=e.targetTouches[1].pageX;
          input.touchOffset2.y=e.targetTouches[1].pageY;
        }
        render.canvas.addEventListener('touchmove', input.onTouchmove);
        render.canvas.addEventListener('touchend', input.onTouchend);
      },
      onTouchmove(e){
        //e.preventDefault();
        let changex=render.canvas.offsetWidth/render.options.width;
        let changey=render.canvas.offsetHeight/render.options.height;
        if(e.targetTouches[1]){
          let page0old=input.position
          let page1old=input.touchOffset2
          let page0new=Vector.create(e.targetTouches[0].pageX,e.targetTouches[0].pageY)
          let page1new=Vector.create(e.targetTouches[1].pageX,e.targetTouches[1].pageY)
          let vold=Vector.sub(page1old,page0old)
          let vnew=Vector.sub(page1new,page0new)
          vold.d=Vector.magnitude(vold)
          vnew.d=Vector.magnitude(vnew)
          try{
          let cpage=Vector.create(render.canvas.offsetWidth/2+render.canvas.offsetLeft, render.canvas.offsetHeight/2+render.canvas.offsetTop)
          let cold=Vector.add(page0old,Vector.div(vold,2))
          let cnew=Vector.add(page0new,Vector.div(vnew,2))
          let move=Vector.sub(cold,cnew)
          Vector.add(move,Vector.mult(Vector.normalise(Vector.sub(cnew,cpage)),(vnew.d-vold.d)/2),move)
          view.lookat(move.x/changex,move.y/changey,(vold.d/vnew.d),true);}catch(e){alert(e)}
          logs((vnew.d-vold.d)/2-(vold.d/vnew.d))
          /*(
              distance((input.position.x-input.touchOffset2.x), (input.position.y-input.touchOffset2.y)) /
              distance((e.targetTouches[0].pageX-e.targetTouches[1].pageX), (e.targetTouches[0].pageY-e.targetTouches[1].pageY))
          )*/
          input.position.x = e.targetTouches[0].pageX;
          input.position.y = e.targetTouches[0].pageY;
          input.touchOffset2.x=e.targetTouches[1].pageX;
          input.touchOffset2.y=e.targetTouches[1].pageY;
        }else{
          view.lookat(-(e.targetTouches[0].pageX - input.position.x)/changex, -(e.targetTouches[0].pageY - input.position.y)/changey, 0);
          input.position.x = e.targetTouches[0].pageX;
          input.position.y = e.targetTouches[0].pageY;
        }
        function distance(x,y){
            return (x**2+y**2)**0.5;
        }
        input.isMove=1;
        //input.offset.x = input.curOffset.x + (e.targetTouches[0].pageX - input.x);
        //input.offset.y = input.curOffset.y + (e.targetTouches[0].pageY - input.y);
        //input.paint();
      },
      onTouchend(){
        input.curOffset.x = input.offset.x;
        input.curOffset.y = input.offset.y;
        render.canvas.removeEventListener('touchmove', input.onTouchmove);
        render.canvas.removeEventListener('touchend', input.onTouchend);
        remember.save();
        if(input.isMove===0){
          
        }else{input.isMove=0;}
      },
      onTouchcancel(){
      
      },
      remember(){
        //...
      }
    };
    //鼠标
    render.canvas.addEventListener('mousedown', input.onMousedown,true);
    render.canvas.addEventListener("wheel",input.onWheel,true);
    render.canvas.addEventListener("touchstart",input.onTouchstart,true);
    
    
    /*
  onMousewheel(e) {
    //废弃的wheel事件
    try{
    e.preventDefault();
    logs(e.wheelDelta)
    this.mousePosition.x = e.offsetX; // 记录当前鼠标点击的横坐标
    this.mousePosition.y = e.offsetY; // 记录当前鼠标点击的纵坐标
    if (e.wheelDelta > 0) {
      // 放大
      this.scale = parseFloat((this.scaleStep + this.scale).toFixed(2)); // 解决小数点运算丢失精度的问题
      if (this.scale > this.maxScale) {
        this.scale = this.maxScale;
        //return;
      }
    } else {
      // 缩小
      this.scale = parseFloat((this.scale - this.scaleStep).toFixed(2)); // 解决小数点运算丢失精度的问题
      if (this.scale < this.minScale) {
        this.scale = this.minScale;
        //return;
      }
    }
  
    this.offset.x = this.mousePosition.x - ((this.mousePosition.x - this.offset.x) * this.scale) / this.preScale;
    this.offset.y = this.mousePosition.y - ((this.mousePosition.y - this.offset.y) * this.scale) / this.preScale;
    //slookat.lookat(this.offset.x,this.offset.y,this.scale)
    //slookat.lookat(0,0,-e.wheelDelta/Math.abs(e.wheelDelta)*parseFloat((this.scaleStep).toFixed(2)))
    view.csize(Math.sign(e.wheelDelta)>0?1.2:0.2,true);
    view.update();
  
    //this.ctx.translate(this.offset.x, this.offset.y);
    //this.ctx.scale(this.scale, this.scale);
    this.preScale = this.scale;
    this.curOffset.x = this.offset.x;
    this.curOffset.y = this.offset.y;
    }catch(e){logs(e)}
    logs(0)
  },*/
  
    
    
    return view;
})();


var camera;
for(let i of Composite.allBodies(engine.world)){
  if(i.label.name==="pig"){
    camera = i;
    //break;
  }
  else if(i.label.name==="TNT"){
    //buttoncontrol.test()
    //break
  }
  switch(i.label.name){
    case "pig":
    break;
    case "TNT":
    break;
    case "pig":
    break;
    case "pig":
    break;
  }
}
view.body=camera;

var lastspeed=0;
Events.on(runner, "beforeUpdate", function(){

  //if(dgbyid("check").checked){slookat.followthings()}
  
  let ctx=render.context;
  let fontsize=20;
  Object.assign(ctx,{
    font:fontsize+"px Arial",
    textAlign:"start",
    fillStyle:"#838CAC"
  });
  let filltexts=[
    "雀斑猪属性: ",
    "  速度: "+Math.round(camera.speed*10)/10,
    "  加速度: "+Math.round(getacceleration(camera.speed)*10)/10,
    "  位置: ("+Math.round(camera.position.x/100)+","+Math.round(camera.position.y/100)+")",
    "  角度: "+Math.round(camera.angle/Math.PI*180%360*10)/10,
    "  角速度: "+Math.round(camera.angularSpeed*10)/10,
    "视野大小: "+Math.round(view.size*5*100)/100,
    "视野位置: ("+Math.round(view.position.x/100)+","+Math.round(view.position.y/100)+")",
    "运行时间: "+Math.round(engine.timing.timestamp)
  ];
  for(let i in filltexts){
    ctx.fillText(filltexts[i], 50, i*fontsize+125);
  }
  
  let speed2=camera.speed;
  setTimeout(function(){
    lastspeed=speed2;
  },1000)
  function getacceleration(speed){
    return speed-lastspeed;
  }
  
  for(let i of Composite.allConstraints(engine.world)){
    let pointA=Constraint.pointAWorld(i);
    let pointB=Constraint.pointBWorld(i);
    let distance=Math.sqrt(Math.pow(Math.abs(pointB.x - pointA.x),2)+Math.pow(Math.abs(pointB.y - pointA.y),2));
    if(Math.abs(i.length-distance)>7){Composite.remove(engine.world, i);}
  }
  
});

var collisiontime=[];
Events.on(engine, 'collisionStart', function(event) {
    var pairs = event.pairs;
    //event{pairs name source}

    for (let i of pairs) {
        var pair = i;
        if(pair.bodyA.id==35||pair.bodyB.id==35){
            for (var ii = 0; ii < Object.keys(event.source.timing).length; ii++) {
            //logs(Object.keys(event.source.timing)[ii]+":"+Object.values(event.source.timing)[ii])
            }
            //logs(pair.bodyA.speed*pair.bodyA.mass/0.01);
            //logs(pair.bodyA.speed)
            //logs(pair.bodyA.mass)
        }
        //fs=mv f=mv/s
        
        if (pair.bodyA.label.name=="TNT" && pair.activeContacts.length > 0) {
            let collision=pair.collision;

            magnitude=Vector.magnitude(collision.penetration);
            if(magnitude>10){
                let b=pair.bodyA;
                controlbody.explode(b.position,b.label.erange,b.label.eforce,b);
            }
        }
    }
    collisiontime.push(engine.timing.timestamp)
});
Events.on(engine, 'collisionActive', function(event) {
    var pairs = event.pairs;

    for (let i of pairs) {
        if(i.bodyB.label.name==="explode"){
            log("explode")
        }
    }
});

var viewtransition={
  place:[],//{x:3,y:100},{x:4000,y:-25},{x:-300,y:605}
  time:[2000,300,2000],
  move:function(){
    if(this.place.length>0){
      if(this.d()<30){
        this.place.shift()
        this.time.shift()
      }else{
        let v=Vector.mult(Vector.sub(this.place[0],view.position),10/this.time[0])
        view.lookat(v.x,v.y,0.001)
        logs(this.d())
      }
    }
  },
  d:function(){
    let v=Vector.sub(this.place[0],view.position)
    return (v.x**2+v.y**2)**0.5
  }
};
setInterval("viewtransition.move()",10)
//var mouse = Mouse.create(render.canvas);
render.canvas.onclick=function(e){
  //logs(e.offsetX+"/"+e.offsetY)
  let clickpoint=clickworld({x:e.offsetX, y:e.offsetY})
  //{x:e.offsetX,y:e.offsetY}
  let clickbody=Query.point(Composite.allBodies(engine.world), clickpoint)
  for(let i of clickbody){
    if(i.label.name==="TNT"){
      controlbody.explode(i.position,i.label.erange,i.label.eforce,i)
    }
  }
  try{build.part.add(clickpoint,"mubox0")}catch(e){alert(e)}
  function clickworld(point){
    return { x:render.bounds.min.x+point.x/render.canvas.offsetWidth*render.canvas.width*view.size,
    y:render.bounds.min.y+point.y/render.canvas.offsetWidth*render.canvas.width*view.size }
  }
}

//collides: pair,collided,bodyA,bodyB,parentA,parentB,depth,normal,tangent,penetration,supports
var controlbody={
  explode:function(point,radius,force,removebody){
    radius=radius||200;
    if(removebody){
      Composite.remove(engine.world,[removebody,...controlbody.getcst(removebody)]);
    }
    let explodeball=Bodies.circle(point.x, point.y, radius, {
      render:{
        visible:true,
        sprite: {
          texture: "https://s1.imagehub.cc/images/2023/05/03/Particles_Sheet_01.png",
          cutx: 0,
          cuty: 260,
          cutwidth: 260,
          cutheight: 260,
          xScale: radius*2/1000,
          yScale: radius*2/1000
        }
      },
      label:{
        name:"explode"
      },
      isSensor:true,
      isStatic:true
    });
    Composite.add(engine.world,[explodeball])
    setTimeout(function(){
        Composite.remove(engine.world,[explodeball])
    },150)
    for(let i of Query.collides(explodeball, Composite.allBodies(engine.world))){
      if(i.bodyA.id!==explodeball.id&&i.bodyA.isStatic===true){continue}
      if(i.bodyA.label.name==="TNT"){
        controlbody.explode({x:i.bodyA.position.x,y:i.bodyA.position.y},i.bodyA.label.erange,i.bodyA.label.eforce,i.bodyA)
      }
      let v=Vector.sub(i.bodyA.position,explodeball.position)
      v.d=Vector.magnitude(v);
      if(v.d>radius){continue}
      v.m=(radius-v.d)/radius*force
      //v.n=v.x>0?Math.atan2(v.y,v.x):-Math.atan2(v.y,v.x);
      Body.applyForce( i.bodyA, i.bodyA.position, Vector.mult(Vector.normalise(v),v.m));
    }
  },
  addforce:function(thebody,m){
    let n=thebody.angle;
    Body.applyForce( thebody, {x: thebody.position.x, y: thebody.position.y}, {x:m*Math.cos(n), y:m*Math.sin(n)});
},
  addvelocity:function(thebody,m){
    let n=thebody.angle;
    Body.setVelocity( thebody, {x:m*Math.cos(n), y:m*Math.sin(n)});
  },
  getcst(body){
      let csts=[];
      for(let cst of Composite.allConstraints(engine.world)){
          if(cst.bodyA.id===body.id||cst.bodyB.id===body.id){
              csts.push(cst);
          }
      }
      return csts;
  }
}

//controlbody.explode({x:3,y:0},200,1)
var buttoncontrol={
  num:0,
  test:function(name,does){
    let button=document.createElement("BUTTON");
    button.className="bu";
    button.addEventListener('click',does);
    button.innerHTML=(name||"bu")+this.num++
    dqsa(".bu")[0].insertBefore(button, dqsa("#fullscreen")[0]);
  }
}
buttoncontrol.test(undefined, function () {
    //Body.scale( mubox0, 1.5, 1.2);//放大
    //Composite.move(mwheel,wsjx,engine.world)
    //Matter.Body.setStatic(body, true)
});
buttoncontrol.test(undefined, function () {//旋转
    Body.rotate( camera, Math.PI/180*45);
});
buttoncontrol.test(undefined, function () {//移动
    //Body.translate( mubox0, {x: 40, y: -20});
    logs(Query.collides(Composite.allBodies(engine.world)[3], Composite.allBodies(engine.world))[0].bodyA.id+"+"+Query.collides(Composite.allBodies(engine.world)[3], Composite.allBodies(engine.world))[0].bodyB.id)
});
buttoncontrol.test(undefined, function () {//移动速度
    Body.setVelocity( mubox0, {x: 00, y: -20});
    Body.setVelocity( febox0, {x: 00, y: 20});
    Body.setVelocity( camera, {x: 10, y: -10});
});
buttoncontrol.test(undefined, function () {//旋转速度
    Body.setAngularVelocity( Composite.allBodies(wheel)[1], Math.PI/180*40);
    //Body.setAngularVelocity( mubox0, Math.PI/6);
});
buttoncontrol.test(undefined, function () {//施加力向右
    //controlbody.addforce(dpen,0.44);
    /*let tick=0;
    let timeout=function(){
      tick++;
      controlbody.addforce(dpen,0.08);
      if(tick<16){
          setTimeout(timeout,150);
      }
    }
    timeout()*/
    let timeout=new Loop(function(){
      controlbody.addforce(dpen,0.08);
    },150)
    timeout.start(15)
    //controlbody.addforce(dpen,0.44);
    //Body.applyForce( obja, {x: obja.position.x, y: obja.position.y}, {x: 0.44, y: 0});
});
buttoncontrol.test(undefined, function () {//向上力
    controlbody.addforce(camera,-0.44);
});
buttoncontrol.test(undefined, function () {//摩擦
  // Object.assign(camera,{
    // friction:0.05,
    // frictionAir:0.0005,
    // restitution:0.9
  // })
  viewtransition.move()
});
buttoncontrol.test(undefined, function () {//暂停

  if(runner.enabled){
    Runner.stop(runner);
    runner.enabled=false;
  }else{logs(899)
    Runner.run(runner, engine);
  }
});

function dqsa(qsqs){return document.querySelectorAll(qsqs);}
function logs(e,br=true){
dgbyid("log").innerHTML+=e+(br?"<br/>":", ");
}



class Loop{
  constructor(event,interval){
    this.tick=0;
    this.times=undefined;
    this.event=function(){
      event();
      if(++this.tick===this.times){this.stop();this.times=undefined;}
    };
    this.event=this.event.bind(this)
    this.interval=interval;
    this.run=undefined;
  }
  start(times){
    this.run=setInterval(this.event,this.interval)
    if(times){
      this.times=times;
    }
  }
  stop(){
    clearInterval(this.run)
  }
}
for(let k of Object.keys(window)){
    //logs(k+":"+window[k])
}
</script>

</body>
</html>